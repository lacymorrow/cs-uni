#include <iostream>#include <cctype>#include <math.h>using namespace std;/* * *	Lacy Morrow *	Calculator *	Oct 29, 2010 *	 *	QUESTIONS: *	1. My calculator does follow precedence rules/orders of operation PEMDAS *	2. The grammar works like a recursive stack, beginning with the  *	least important operators (+,-) and evaluating the important operations *	before returning to evaluate the first low priority ones. * * */void match(char lookahead, char& curr);void error();double Expr(char& curr);double Term(char& curr);double Factor(char& curr);double Number(char& curr);void match(char lookahead, char& curr){	if (curr == lookahead){		cin.get(curr);		while (curr==' ' || curr=='\t') {			cin.get(curr);		}	}else {		error();	}}void error(){	cout << "Expression contains a syntax error." << endl;	exit(1);}double RealNum(char& curr){	bool neg = false;	double result;	if (curr == '+' || curr == '-') {		if (curr == '-')			neg = true;		match(curr, curr);	}	double hold = Number(curr);	match(curr, curr);	if (curr == '.'){		match(curr, curr);		result = result + hold + '.' + Number(curr);		match(curr, curr);	} else {		result = result + hold;		match(curr, curr);	}	neg = false;	if (curr == 'E' || curr == 'e') {		match(curr, curr);		if (curr == '+' || curr == '-') {			if (curr == '-')				neg = true;			match(curr, curr);		}		hold = Number(curr);		match(curr,curr);		if (neg) hold =-hold;		result = pow(result,hold);	}	return result;}double Expr(char& curr){	bool neg = false;	double result;	if (curr == '+' || curr == '-') {		if (curr == '-')			neg = true;		match(curr, curr);	}	result = Term(curr);	if (neg) result =-result;	while (curr == '+' || curr == '-') {		if(curr == '+'){			match(curr, curr);			result = result+Term(curr);		} else {			match(curr,curr);			result = result-Term(curr);		}	}	return result;}double Term(char& curr){	double result;	result = Factor(curr);	while (curr == '*' || curr == '/') {		if(curr == '*'){			match(curr, curr);			result = result*Factor(curr);		} else {			match(curr,curr);			result = result/Factor(curr);		}	}	return result;}double Factor(char& curr){	double result;	bool neg = false;	double hold;	if (isdigit(curr)) {		result = Number(curr);	} else if (curr == '(') {		match('(', curr);		result = Expr(curr);		match(')', curr);	} else if (curr == '+' || curr == '-') {		if (curr == '-')			neg = true;		match(curr, curr);		result = Number(curr);		if (neg) result =-result;	} else {		error();	}	return result;}double Number(char& curr){	double result;	cin.unget();	cin >> result;	cin.get(curr);	return result;}int main(void){	double result;	char curr;	cout << "Enter a string for parsing: ";	cin.get(curr);	result = Expr(curr);	if (curr == '\n')		cout << "Expression evaluates to " << result << endl;	else		error();	return 0;}