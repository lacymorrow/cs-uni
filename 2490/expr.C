#include <iostream>#include <cctype>using namespace std;/* * *	Lacy Morrow *	Recursive Descent Parser *	Oct 29, 2010 * */void match(char lookahead, char& curr);void error();void Expr(char& curr);void Term(char& curr);void Factor(char& curr);void Number(char& curr);void Digit(char& curr);void AddOp(char& curr);void MulOp(char& curr);void F(char& curr);void G(char& curr);void H(char& curr);void I(char& curr);void match(char lookahead, char& curr){	if (curr == lookahead)		cin.get(curr);	else error();}void error(){	cout << "syntax error" << endl;	exit(1);}void Expr(char& curr){	F(curr);	Term(curr);	G(curr);	return;}void F(char& curr){	if (curr == '+' || curr == '-') {		AddOp(curr);	}	return;}void G(char& curr){	if (curr == '+' || curr == '-') {		AddOp(curr);		Term(curr);		G(curr);	}	return;}void Term(char& curr){	Factor(curr);	H(curr);	return;}void H(char& curr){	if (curr == '*' || curr == '/') {		MulOp(curr);		Factor(curr);		H(curr);	}	return;}void Factor(char& curr){	if (isdigit(curr)) {		Number(curr);	} else if (curr == '(') {		match('(', curr);		Expr(curr);		match(')', curr);	} else {		error();	}	return;}void AddOp(char& curr){	if (curr == '+' || curr == '-') {		match(curr, curr);	} else {		error();	}	return;}void MulOp(char& curr){	if (curr == '*' || curr == '/') {		match(curr, curr);	} else {		error();	}	return;}void Number(char& curr){	if (isdigit(curr)){		Digit(curr);		I(curr);	}	return;}void I(char& curr){	if (isdigit(curr)){		Digit(curr);		I(curr);	}	return;}void Digit(char& curr){	if (isdigit(curr)) 		match(curr, curr);	else {		error();	}	return;}int main(void){	char curr;	cout << "Enter a string for parsing: ";	cin.get(curr);	Expr(curr);	if (curr == '\n')		cout << "Expression is valid." << endl;	else		error();}